<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>解决node.js mysql客户端不支持认证协议引发的“ER_NOT_SUPPORTED_AUTH_MODE”问题</title>
      <link href="/posts/35c7b920-8f06-11ec-ade8-474d01fc45a2/"/>
      <url>/posts/35c7b920-8f06-11ec-ade8-474d01fc45a2/</url>
      
        <content type="html"><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>当我在使用node的sequelize连接mysql8.0数据库时发生以下异常:</p><pre class="language-none"><code class="language-none">at Socket.emit (node:events:394:28)    at addChunk (node:internal&#x2F;streams&#x2F;readable:315:12)    at readableAddChunk (node:internal&#x2F;streams&#x2F;readable:289:9)    at Socket.Readable.push (node:internal&#x2F;streams&#x2F;readable:228:10)    at TCP.onStreamRead (node:internal&#x2F;stream_base_commons:199:23) &#123;  code: &#39;ER_NOT_SUPPORTED_AUTH_MODE&#39;,  errno: 1251,  sqlState: &#39;08004&#39;,  sqlMessage: &#39;Client does not support authentication protocol requested by server; consider upgrading MySQL client&#39;&#125;,original: Error: Client does not support authentication protocol requested by server; consider upgrading MySQL client</code></pre><h2 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h2><p>Node最新的mysql模块并未完全支持MySQL 8的“caching_sha2_password”加密方式，而“caching_sha2_password”在MySQL 8中是默认的加密方式。因此，下面的方式命令是默认已经使用了“caching_sha2_password”加密方式，该账号对应的密码无法在Node mysql模块下被识别。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>修改用户密码的加密方式</p><p>查询对应用户的host及plugin</p><pre class="language-none"><code class="language-none">mysql&gt; select user,host, plugin from mysql.user;+------------------+------+-----------------------+| user             | host | plugin                |+------------------+------+-----------------------+|                  |      | caching_sha2_password || mysql.infoschema | %    | caching_sha2_password || mysql.session    | %    | caching_sha2_password || mysql.sys        | %    | caching_sha2_password || root             | %    | caching_sha2_password |+------------------+------+-----------------------+</code></pre><p>从查询结果中可以看出root用户使用了caching_sha2_password方式加密密码, 将其修改为Node mysql支持的mysql_native_password方式</p><pre class="language-none"><code class="language-none"># root为待连接的用户, % 需要根据上方sql语句的host查询结果录入, 一般为localhost或%mysql&gt; ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;密码&#39;;Query OK, 0 rows affected (0.12 sec)</code></pre><p>修改完成后重新查询:</p><pre class="language-none"><code class="language-none">mysql&gt; select user,host, plugin from mysql.user;+------------------+------+-----------------------+| user             | host | plugin                |+------------------+------+-----------------------+|                  |      | caching_sha2_password || mysql.infoschema | %    | caching_sha2_password || mysql.session    | %    | caching_sha2_password || mysql.sys        | %    | caching_sha2_password || root             | %    | mysql_native_password |+------------------+------+-----------------------+</code></pre><p>root用户对应的plugin被改为了mysql_native_password, 重新运行Node代码即可</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Compose配置详解</title>
      <link href="/posts/61a3c330-8e21-11ec-a105-f340cf877f8a/"/>
      <url>/posts/61a3c330-8e21-11ec-a105-f340cf877f8a/</url>
      
        <content type="html"><![CDATA[<p>本文参考自 <a href="https://www.runoob.com/docker/docker-compose.html">https://www.runoob.com/docker/docker-compose.html</a></p><h2 id="Compose简介"><a href="#Compose简介" class="headerlink" title="Compose简介"></a>Compose简介</h2><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p><p>应用场景:</p><p>比如一个web服务包含web应用程序, 数据库等等, 我们本地构建一个web应用程序Dockfile, 再构建一个数据库Dockfile, 通过Compose可以将两个服务在隔离环境中一起运行</p><h2 id="docker-compose-yml-配置指令参考"><a href="#docker-compose-yml-配置指令参考" class="headerlink" title="docker-compose.yml 配置指令参考"></a>docker-compose.yml 配置指令参考</h2><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>指定本 yml 依从的 compose 哪个版本制定的。</p><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>指定为构建镜像上下文路径：<br>例如 webapp 服务，指定为从上下文路径 ./dir/Dockerfile 所构建的镜像</p><pre class="language-none"><code class="language-none">version: &quot;3.7&quot;services:webapp:build: .&#x2F;dir</code></pre><p>或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：</p><pre class="language-none"><code class="language-none">version: &quot;3.7&quot;services:  webapp:    build:      context: .&#x2F;dir      dockerfile: Dockerfile-alternate      args:        buildno: 1      labels:        - &quot;com.example.description&#x3D;Accounting webapp&quot;        - &quot;com.example.department&#x3D;Finance&quot;        - &quot;com.example.label-with-empty-value&quot;      target: prod</code></pre><ul><li>context：上下文路径。</li><li>dockerfile：指定构建镜像的 Dockerfile 文件名。</li><li>args：添加构建参数，这是只能在构建过程中访问的环境变量。</li><li>labels：设置构建镜像的标签。</li><li>target：多层构建，可以指定构建哪一层。</li></ul><h3 id="cap-add，cap-drop"><a href="#cap-add，cap-drop" class="headerlink" title="cap_add，cap_drop"></a>cap_add，cap_drop</h3><p>添加或删除容器拥有的宿主机的内核功能。</p><pre class="language-none"><code class="language-none">cap_add:  - ALL # 开启全部权限cap_drop:  - SYS_PTRACE # 关闭 ptrace权限</code></pre><h3 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h3><p>为容器指定父 cgroup 组，意味着将继承该组的资源限制。</p><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>覆盖容器启动的默认命令</p><h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>指定容器名称</p><h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><p>设置依赖关系</p><ul><li>docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。</li><li>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。</li><li>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。</li></ul><h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h3><p>指定设备映射列表 (等同于 docker run –device 的作用)</p><h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h3><p>自定义DNS服务器。可以是单个值或列表。(等同于 docker run –dns 的作用)</p><h3 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h3><p>设置 DNS 搜索域(等同于 docker run –dns-search 的作用)</p><h3 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h3><p>覆盖容器的默认 entrypoint 指令 (等同于 docker run –entrypoint 的作用)</p><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>添加环境变量。可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。</p><pre class="language-none"><code class="language-none">environment:  RACK_ENV: development  SHOW: &#39;true&#39;</code></pre><h3 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h3><p>指定环境变量文件。可以是单个值或列表的多个值。</p><pre class="language-none"><code class="language-none">env_file:  - .&#x2F;common.env  - .&#x2F;apps&#x2F;web.env  - &#x2F;opt&#x2F;secrets.env</code></pre><h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p><p>仅可以指定内部端口为参数：</p><pre class="language-none"><code class="language-none">expose: - &quot;3000&quot; - &quot;8000&quot;</code></pre><h3 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h3><p>添加主机名映射。类似 docker client –add-host。</p><pre class="language-none"><code class="language-none">extra_hosts: - &quot;somehost:162.242.195.82&quot; - &quot;otherhost:50.31.209.229&quot;</code></pre><p>以上会在此服务的内部容器中 /etc/hosts 创建一个具有 ip 地址和主机名的映射关系：</p><pre class="language-none"><code class="language-none">162.242.195.82  somehost50.31.209.229   otherhost</code></pre><h3 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h3><p>用于检测 docker 服务是否健康运行。类似于 Dockerfile 的 HEALTHCHECK 指令</p><pre class="language-none"><code class="language-none">healthcheck:  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost&quot;] # 设置检测程序  interval: 1m30s # 设置检测间隔  timeout: 10s # 设置检测超时时间  retries: 3 # 设置重试次数  start_period: 40s # 启动后，多少秒开始启动检测程序</code></pre><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>指定容器运行的镜像。以下格式都可以：</p><pre class="language-none"><code class="language-none">image: redisimage: ubuntu:14.04image: tutum&#x2F;influxdbimage: example-registry.com:4000&#x2F;postgresqlimage: a4bc65fd # 镜像id</code></pre><h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>服务的日志记录配置。</p><p>driver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项</p><pre class="language-none"><code class="language-none">driver: &quot;json-file&quot;driver: &quot;syslog&quot;driver: &quot;none&quot;</code></pre><p>仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。</p><pre class="language-none"><code class="language-none">logging:  driver: json-file  options:    max-size: &quot;200k&quot; # 单个文件大小为200k    max-file: &quot;10&quot; # 最多10个文件</code></pre><p>当达到文件限制上限，会自动删除旧得文件。</p><p>syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。</p><pre class="language-none"><code class="language-none">logging:  driver: syslog  options:    syslog-address: &quot;tcp:&#x2F;&#x2F;192.168.0.42:123&quot;</code></pre><h3 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h3><p>设置网络模式</p><pre class="language-none"><code class="language-none">network_mode: &quot;bridge&quot;network_mode: &quot;host&quot;network_mode: &quot;none&quot;network_mode: &quot;service:[service name]&quot;network_mode: &quot;container:[container name&#x2F;id]&quot;</code></pre><h3 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h3><p>配置容器连接的网络，引用顶级 networks 下的条目 。</p><pre class="language-none"><code class="language-none">services:  some-service:    networks:      some-network:        aliases:         - alias1      other-network:        aliases:         - alias2networks:  some-network:    # Use a custom driver    driver: custom-driver-1  other-network:    # Use a custom driver which takes special options    driver: custom-driver-2</code></pre><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><pre><code>- no：是默认的重启策略，在任何情况下都不会重启容器。- always：容器总是重新启动。- on-failure：在容器非正常退出时（退出状态非0），才会重启容器。- unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</code></pre><pre class="language-none"><code class="language-none">restart: &quot;no&quot;restart: alwaysrestart: on-failurerestart: unless-stopped</code></pre><h3 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h3><p>存储敏感数据，例如密码：</p><pre class="language-none"><code class="language-none">version: &quot;3.1&quot;services:mysql:  image: mysql  environment:    MYSQL_ROOT_PASSWORD_FILE: &#x2F;run&#x2F;secrets&#x2F;my_secret  secrets:    - my_secretsecrets:  my_secret:    file: .&#x2F;my_secret.txt</code></pre><h3 id="stop-grace-period"><a href="#stop-grace-period" class="headerlink" title="stop_grace_period"></a>stop_grace_period</h3><p>指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。默认的等待时间是 10 秒。</p><pre class="language-none"><code class="language-none">stop_grace_period: 1s # 等待 1 秒stop_grace_period: 1m30s # 等待 1 分 30 秒 </code></pre><h3 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a>stop_signal</h3><p>设置停止容器的替代信号。默认情况下使用 SIGTERM 。</p><p>以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。</p><pre class="language-none"><code class="language-none">stop_signal: SIGUSR1</code></pre><h3 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h3><p>设置容器中的内核参数，可以使用数组或字典格式。</p><pre class="language-none"><code class="language-none">sysctls:  net.core.somaxconn: 1024  net.ipv4.tcp_syncookies: 0sysctls:  - net.core.somaxconn&#x3D;1024  - net.ipv4.tcp_syncookies&#x3D;0</code></pre><h3 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h3><p>在容器内安装一个临时文件系统。可以是单个值或列表的多个值。</p><pre class="language-none"><code class="language-none">tmpfs: &#x2F;runtmpfs:  - &#x2F;run  - &#x2F;tmp</code></pre><h3 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h3><p>覆盖容器默认的 ulimit。</p><pre class="language-none"><code class="language-none">ulimits:  nproc: 65535  nofile:    soft: 20000    hard: 40000</code></pre><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>将主机的数据卷或着文件挂载到容器里。</p><pre class="language-none"><code class="language-none">version: &quot;3.7&quot;services:  db:    image: postgres:latest    volumes:      - &quot;&#x2F;localhost&#x2F;postgres.sock:&#x2F;var&#x2F;run&#x2F;postgres&#x2F;postgres.sock&quot;      - &quot;&#x2F;localhost&#x2F;data:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="/posts/17954850-8d67-11ec-8505-fffcfa42a684/"/>
      <url>/posts/17954850-8d67-11ec-8505-fffcfa42a684/</url>
      
        <content type="html"><![CDATA[<h2 id="Dockerhub-搜索下载远程镜像"><a href="#Dockerhub-搜索下载远程镜像" class="headerlink" title="Dockerhub 搜索下载远程镜像"></a>Dockerhub 搜索下载远程镜像</h2><pre class="language-none"><code class="language-none"># 搜索docker search ImageName# 下载docker pull ImageName 或 docker pull ImageName:VersionNumber</code></pre><h2 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h2><pre class="language-none"><code class="language-none">docker images [OPTIONS] [REPOSITORY[:TAG]]</code></pre><p>OPTIONS说明：</p><p>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；<br>–digests :显示镜像的摘要信息；<br>-f :显示满足条件的镜像；<br>–format :指定返回值的模板文件；<br>–no-trunc :显示完整的镜像信息；<br>-q :只显示镜像ID。</p><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><pre class="language-none"><code class="language-none">docker rmi ImageNamedocker rmi ImageName:VersionNumber</code></pre><h2 id="Dockerfile本地构建容器"><a href="#Dockerfile本地构建容器" class="headerlink" title="Dockerfile本地构建容器"></a>Dockerfile本地构建容器</h2><pre class="language-none"><code class="language-none">docker build -t image_name Dockerfile_path</code></pre><p>常用选项说明：</p><p>–build-arg=[] :设置镜像创建时的变量；<br>–cpu-shares :设置 cpu 使用权重；<br>–cpu-period :限制 CPU CFS周期；<br>–cpu-quota :限制 CPU CFS配额；<br>–cpuset-cpus :指定使用的CPU id；<br>–cpuset-mems :指定使用的内存 id；<br>–disable-content-trust :忽略校验，默认开启；<br>-f :指定要使用的Dockerfile路径；<br>–force-rm :设置镜像过程中删除中间容器；<br>–isolation :使用容器隔离技术；<br>–label=[] :设置镜像使用的元数据；<br>-m :设置内存最大值；<br>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；<br>–no-cache :创建镜像的过程不使用缓存；<br>–pull :尝试去更新镜像的新版本；<br>–quiet, -q :安静模式，成功后只输出镜像 ID；<br>–rm :设置镜像成功后删除中间容器；<br>–shm-size :设置/dev/shm的大小，默认值是64M；<br>–ulimit :Ulimit配置。<br>–squash :将 Dockerfile 中所有的操作压缩为一层。<br>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。<br>–network: 默认 default。在构建期间设置RUN指令的网络模式</p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><pre class="language-none"><code class="language-none"># 启动容器，如果本地没有要启动的镜像，会自动下载,每次新建一个容器docker run ImageName# 只是单纯的启动。不会新建容器docker start Name or ID# 交互是进入容器docker run -it ImageName &#x2F;bin&#x2F;bash</code></pre><p>常用选项说明：</p><p>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；<br>-d: 后台运行容器，并返回容器ID；<br>-i: 以交互模式运行容器，通常与 -t 同时使用；<br>-P: 随机端口映射，容器内部端口随机映射到主机的端口<br>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口<br>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>–name=”nginx-lb”: 为容器指定一个名称；<br>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；<br>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；<br>-h “mars”: 指定容器的hostname；<br>-e username=”ritchie”: 设置环境变量；<br>–env-file=[]: 从指定文件读入环境变量；<br>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；<br>-m :设置容器使用内存最大值；<br>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；<br>–expose=[]: 开放一个端口或一组端口；<br>–volume , -v: 绑定一个卷</p><h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><pre class="language-none"><code class="language-none"># 列出所有容器docker ps -a# 仅查看当前正在运行的所有容器docker ps# 查看最后一次运行的容器docker ps -l# 查看容器日志docker logs Name&#x2F;ID# 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A：增加的，D： 删除的，C： 被改变的 docker diff Name&#x2F;ID# 查看容器进程piddocker top Name&#x2F;ID</code></pre><h2 id="启动、停止、杀死一个容器"><a href="#启动、停止、杀死一个容器" class="headerlink" title="启动、停止、杀死一个容器"></a>启动、停止、杀死一个容器</h2><pre class="language-none"><code class="language-none"># 启动容器docker start Name&#x2F;ID# docker stop，支持“优雅退出”。先发送SIGTERM信号，在一段时间之后（10s）再发送SIGKILL信号。Docker内部的应用程序可以接收SIGTERM信号，然后做一些“退出前工作”，比如保存状态、处理当前请求等。# docker kill，发送SIGKILL信号，应用程序直接退出。docker stop Name&#x2F;IDdocker kill Name&#x2F;ID# 重启容器docker restart Name&#x2F;ID</code></pre><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><pre class="language-none"><code class="language-none"># 删除所有容器docker rm &#96;docker ps -a -q&#96;# 删除单个容器docker rm Name&#x2F;ID</code></pre><h2 id="连接到正在运行中的容器"><a href="#连接到正在运行中的容器" class="headerlink" title="连接到正在运行中的容器"></a>连接到正在运行中的容器</h2><pre class="language-none"><code class="language-none"># --sig-proxy&#x3D;false ：此选项作用是按CTRL-D或CTRL-C不会关闭容器docker attach --sig-proxy&#x3D;false Name&#x2F;ID</code></pre><h2 id="根据容器变动创建新的镜像"><a href="#根据容器变动创建新的镜像" class="headerlink" title="根据容器变动创建新的镜像"></a>根据容器变动创建新的镜像</h2><pre class="language-none"><code class="language-none">docker commit ID new_image_name</code></pre><p>常用选项说明:<br>-a :提交的镜像作者；<br>-c :使用Dockerfile指令来创建镜像；<br>-m :提交时的说明文字；<br>-p :在commit时，将容器暂停。</p><h2 id="保存和加载镜像"><a href="#保存和加载镜像" class="headerlink" title="保存和加载镜像"></a>保存和加载镜像</h2><pre class="language-none"><code class="language-none"># 保存镜像到一个tar包docker save image_name -o file_path# 加载一个tar包对象docker load -i file_path</code></pre><h2 id="Dockefile-指令说明"><a href="#Dockefile-指令说明" class="headerlink" title="Dockefile 指令说明"></a>Dockefile 指令说明</h2><ul><li><p>FROM<br>构建镜像基于哪个镜像</p></li><li><p>MAINTAINER<br>镜像维护者姓名或邮箱地址</p></li><li><p>RUN<br>构建镜像时运行的指令</p></li><li><p>CMD<br>运行容器时执行的shell环境</p></li><li><p>VOLUME<br>指定容器挂载点到宿主机自动生成的目录或其他容器</p></li><li><p>USER<br>为RUN、CMD、和 ENTRYPOINT 执行命令指定运行用户</p></li><li><p>WORKDIR<br>为 RUN、CMD、ENTRYPOINT、COPY 和 ADD 设置工作目录，就是切换目录</p></li><li><p>HEALTHCHECH<br>健康检查</p></li><li><p>ARG<br>构建时指定的一些参数</p></li><li><p>EXPOSE<br>声明容器的服务端口（仅仅是声明）</p></li><li><p>ENV<br>设置容器环境变量</p></li><li><p>ADD<br>拷贝文件或目录到容器中，如果是URL或压缩包便会自动下载或自动解压</p></li><li><p>COPY<br>拷贝文件或目录到容器中，跟ADD类似，但不具备自动下载或解压的功能</p></li><li><p>ENTRYPOINT<br>运行容器时执行的shell命令</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 常用命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令收集</title>
      <link href="/posts/f9c13f40-7f52-11ec-8b0d-2f0f3094676b/"/>
      <url>/posts/f9c13f40-7f52-11ec-8b0d-2f0f3094676b/</url>
      
        <content type="html"><![CDATA[<h2 id="远程仓库拉取代码"><a href="#远程仓库拉取代码" class="headerlink" title="远程仓库拉取代码"></a>远程仓库拉取代码</h2><pre class="language-none"><code class="language-none"># 拉取一个项目和它的整个代码历史git clone [https url|ssh url]# 拉取指定分支git clone [https url|ssh url] -b [branch] # 仅拉取最近一次提交git clone [https url|ssh url] --depth 1# 本地关联远程仓库拉取代码git remote add origin [https url|ssh url]git pull origin [branch]</code></pre><h2 id="查看仓库信息"><a href="#查看仓库信息" class="headerlink" title="查看仓库信息"></a>查看仓库信息</h2><pre class="language-none"><code class="language-none"># 查看仓库当前的状态git status# 简化状态输出git status -s#查看指定文件的修改记录git blame [filename]# 查看未add文件变动git diff# 查看已add文件变动gut diff --cached# 查看已add和未add文件的变动git diff HEAD# 显示变动文件摘要git diff --stat# 对比两次提交的差异, 或两个分支的差异git diff [first-branch] [second-branch]# 查看历史提交git log# 查看简化版历史提交git log --oneline# 查看合并拓扑图git log --graph # 逆向展示历史提交git log --reverse# 查看指定作者的历史提交git log --author&#x3D;[name]# 查看指定日期内的提交git log --oneline --before&#x3D;&#123;2022-01-18&#125; --after&#x3D;&#123;2020-01-18&#125;# 查看仓库所有变动信息, reflog-id也可用作回退git reflog</code></pre><h2 id="添加-删除-重命名文件"><a href="#添加-删除-重命名文件" class="headerlink" title="添加/删除/重命名文件"></a>添加/删除/重命名文件</h2><pre class="language-none"><code class="language-none"># 添加指定文件或目录到暂存区git add [filename]# 添加当前目录所有文件到暂存区git add .# 添加所有文件到暂存区git add --all# 删除文件git rm [filename]# 强制删除, 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 git rm [filename] -f# 把文件从暂存区域移除，但仍然希望保留在当前工作目录中git rm --cached [filename]# 文件重命名git mv [filename] [newfilename]# 强制重命名, 覆盖重复文件git mv -f [filename] [newfilename]</code></pre><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><pre class="language-none"><code class="language-none"># 提交所有暂存区文件git commit -m [msg]# 提交指定文件git commit [file1] [file2] ... -m [msg]# 追加提交, 不产生新的commit的情况下将新修改的代码追加到前一次的commit中# 也可用于修改commit msggit commit --amend# 空提交, 一般用于重跑cigit commit --allow-empty -m [msg]</code></pre><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><pre class="language-none"><code class="language-none"># 回退至上个版本git reset HEAD^# 回退某个文件到上个版本git reset HEAD^ [filename]# 回退到指定版本并保留当前版本改动git reset [commit-id]# 舍弃当前版本改动回退至指定版本git reset --hard [commit-id]# 回退到指定版本并将改动加入暂存区git reset --soft [commit-id]# 创建一个新的提交回退指定版本的内容(将制定commit-id提交的代码删除并生成一个新的提交)git revert [commit-id]</code></pre><h2 id="代码合并"><a href="#代码合并" class="headerlink" title="代码合并"></a>代码合并</h2><pre class="language-none"><code class="language-none"># 将指定分支合并到当前分支, 有冲突需要解决冲突并提交新的commitgit merge [branch]# 将指定分支作为base分支, 先处理冲突后按照时间线将commit合并, 对比merge合并提交的代码更加整洁git rebase [branch]# 将指定提交合并到当前分支git cherry-pick [commit-id]</code></pre><h2 id="stash保存及恢复进度"><a href="#stash保存及恢复进度" class="headerlink" title="stash保存及恢复进度"></a>stash保存及恢复进度</h2><pre class="language-none"><code class="language-none"># 清理stash暂存区git stash clear# 将当前变动代码加入stash暂存区git stash # 查看stash暂存区内容git stash list # 将最后加入暂存区的内容提取到当前分支, 并从stash暂存区中删除git stash pop# 弹出stash暂存区中的指定内容git stash pop [stash-id]</code></pre><h2 id="git-commit-Angular规范"><a href="#git-commit-Angular规范" class="headerlink" title="git commit Angular规范"></a>git commit Angular规范</h2><p>commit message的规范有助于我们对于提交历史的追溯, 也会让我们在每次提交时更加慎重</p><p>格式如下</p><pre class="language-none"><code class="language-none">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code></pre><ul><li><p>type(必须)</p><p>  用于说明git commit的类别，只允许使用下面的标识。</p></li><li><p>scope(可选)</p><p>  scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p>  例如在Angular，可以是location，browser，compile，compile，rootScope， ngHref，ngClick，ngView等。如果你的修改影响了不止一个scope，你可以使用*代替。</p></li><li><p>subject(必须)</p><p>  subject是commit目的的简短描述，不超过50个字符。</p></li></ul><table><thead><tr><th>type选项</th><th>描述</th></tr></thead><tbody><tr><td>feat</td><td>新功能（feature）。</td></tr><tr><td>fix/to</td><td>修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。</td></tr><tr><td>fix</td><td>产生diff并自动修复此问题。适合于一次提交直接修复问题</td></tr><tr><td>to</td><td>只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix</td></tr><tr><td>docs</td><td>文档（documentation）。</td></tr><tr><td>style</td><td>格式（不影响代码运行的变动）。</td></tr><tr><td>refactor</td><td>重构（即不是新增功能，也不是修改bug的代码变动）。</td></tr><tr><td>test</td><td>增加测试。</td></tr><tr><td>chore</td><td>构建过程或辅助工具的变动。</td></tr><tr><td>revert</td><td>回滚到上一个版本。</td></tr><tr><td>merge</td><td>代码合并。</td></tr><tr><td>sync</td><td>同步主线或分支的Bug。</td></tr></tbody></table><p>提交示例</p><pre class="language-none"><code class="language-none">fix(login): 修复账号中有不合法字符导致校验错误feat(export): 增加导出功能 </code></pre>]]></content>
      
      
      <categories>
          
          <category> 常用命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Pages+Hexo+Matery主题搭建个人博客</title>
      <link href="/posts/1bfa13c0-7e9a-11ec-a2eb-93bcbf8a55e3/"/>
      <url>/posts/1bfa13c0-7e9a-11ec-a2eb-93bcbf8a55e3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>随着工作经历等增加, 个人所接触的知识面广度也在增加, 最近发现有的之前掌握但很久不用的技术逐渐被遗忘, 于是决定创建此博客用做记录我的技术成长, 也方便在日后哪天需要用到对应知识时可以快速重温。</li><li>搭建博客的方式有很多种, 博客类的开源项目也很多, 综合搭建成本, 可扩展性, 性能等因素最终决定使用Git Pages+Hexo方式搭建</li></ul><h2 id="本文所使用环境如下"><a href="#本文所使用环境如下" class="headerlink" title="本文所使用环境如下:"></a>本文所使用环境如下:</h2><ul><li>  MacOs-11.0.1</li><li>  Node-16.9.1</li><li>  Hexo-5.4.1</li></ul><h2 id="GitHub创建Git-Pages仓库"><a href="#GitHub创建Git-Pages仓库" class="headerlink" title="GitHub创建Git Pages仓库"></a>GitHub创建Git Pages仓库</h2><ul><li>  登陆GitHub，新建一个名为”你的用户名.github.io”的仓库</li><li>  创建index.html文件并输入任意内容</li><li>  浏览器访问”https://你的用户名.github.io”查看是否创建成功</li></ul><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><pre class="language-python" data-language="python"><code class="language-python">brew install node# 安装淘宝镜像npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</code></pre><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><pre class="language-none"><code class="language-none">npm install -g hexo-cli</code></pre><h2 id="创建hexo博客"><a href="#创建hexo博客" class="headerlink" title="创建hexo博客"></a>创建hexo博客</h2><pre class="language-none"><code class="language-none">mkdir blogscd blogshexo initnpm install# 测试目录是否初始化成功hexo ghexo s</code></pre><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ul><li>  修改blogs/_config.yml关联Git Pages仓库</li></ul><pre class="language-none"><code class="language-none">deploy:    type: git    repo: [Git Pages仓库地址]    branch: master# 安装部署插件npm install hexo-deployer-git --save# 部署hexo cleanhexo d</code></pre><ul><li>  浏览器访问”https://你的用户名.github.io”查看是否部署成功</li></ul><h2 id="更换Matery主题"><a href="#更换Matery主题" class="headerlink" title="更换Matery主题"></a>更换Matery主题</h2><ul><li><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">Matery中文文档</a><ul><li>按照文档中内容完成配置</li></ul></li></ul><h2 id="发布新的博客"><a href="#发布新的博客" class="headerlink" title="发布新的博客"></a>发布新的博客</h2><pre class="language-none"><code class="language-none">hexo new post 文章名称hexo cleanhexo d -g # 生成并部署</code></pre><h2 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h2><ul><li><p>Matery支持对指定文章进行加密, 即访问文章前需要校验密码</p><ul><li>修改主题配置, 即themes目录下指定主题的_config.yml文件<ul><li>  找到配置中的verifyPassword开启</li></ul></li><li>  在需要加密的文章Front-matter中增加 password: SHA256加密密码(注: 需要将sha256结果转为16进制纯小写, 谷歌搜到的很多在线工具默认加密结果为大写会导致密码校验失败)</li><li>  访问文章时弹窗中输入sha256加密前的密码</li></ul></li><li><p>hexo-blog-encrypt插件实现文章加密</p><ul><li>  安装加密插件<pre class="language-none"><code class="language-none">npm install hexo-blog-encrypt --save</code></pre></li><li>  外层配置文件增加配置项(注: 并非选定主题中的_config.yml)<pre class="language-none"><code class="language-none"># Security# 在需要加密的文章中增加private或protected标签即可, 访问密码为tags中对应passwordencrypt: # hexo-blog-encrypt    silent: true    abstract: 这是一篇加密文章，需要密码才能继续阅读。    message: 当前文章暂不对外可见，请输入密码后查看！    tags:      - &#123;name: private, password: password1&#125;    - &#123;name: protected, password: password2&#125;    wrong_pass_message: 抱歉，您输入的密码错误，请检查后重新输入。    wrong_hash_message: 抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。</code></pre></li></ul></li></ul><h2 id="固定url"><a href="#固定url" class="headerlink" title="固定url"></a>固定url</h2><p>解决修改文章名后url变化问题</p><pre class="language-none"><code class="language-none">npm install hexo-uuid --save</code></pre><p>修改外部_config.xml配置文件中的permalink</p><pre class="language-none"><code class="language-none">permalink: posts&#x2F;:uuid&#x2F;</code></pre><h2 id="Front-matter-可选项"><a href="#Front-matter-可选项" class="headerlink" title="Front-matter 可选项"></a>Front-matter 可选项</h2><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="language-none"><code class="language-none">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: &#x2F;source&#x2F;images&#x2F;xxx.jpgtop: truehide: falsecover: truecoverImg: &#x2F;images&#x2F;1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
