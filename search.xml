<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git常用命令收集</title>
    <url>/posts/f9c13f40-7f52-11ec-8b0d-2f0f3094676b/</url>
    <content><![CDATA[<h2 id="远程仓库拉取代码"><a href="#远程仓库拉取代码" class="headerlink" title="远程仓库拉取代码"></a>远程仓库拉取代码</h2><pre class="language-none"><code class="language-none"># 拉取一个项目和它的整个代码历史
git clone [https url|ssh url]
# 拉取指定分支
git clone [https url|ssh url] -b [branch] 
# 仅拉取最近一次提交
git clone [https url|ssh url] --depth 1
# 本地关联远程仓库拉取代码
git remote add origin [https url|ssh url]
git pull origin [branch]</code></pre>

<h2 id="查看仓库信息"><a href="#查看仓库信息" class="headerlink" title="查看仓库信息"></a>查看仓库信息</h2><pre class="language-none"><code class="language-none"># 查看仓库当前的状态
git status
# 简化状态输出
git status -s
#查看指定文件的修改记录
git blame [filename]
# 查看未add文件变动
git diff
# 查看已add文件变动
gut diff --cached
# 查看已add和未add文件的变动
git diff HEAD
# 显示变动文件摘要
git diff --stat
# 对比两次提交的差异, 或两个分支的差异
git diff [first-branch] [second-branch]
# 查看历史提交
git log
# 查看简化版历史提交
git log --oneline
# 查看合并拓扑图
git log --graph 
# 逆向展示历史提交
git log --reverse
# 查看指定作者的历史提交
git log --author&#x3D;[name]
# 查看指定日期内的提交
git log --oneline --before&#x3D;&#123;2022-01-18&#125; --after&#x3D;&#123;2020-01-18&#125;
# 查看仓库所有变动信息, reflog-id也可用作回退
git reflog</code></pre>

<h2 id="添加-删除-重命名文件"><a href="#添加-删除-重命名文件" class="headerlink" title="添加/删除/重命名文件"></a>添加/删除/重命名文件</h2><pre class="language-none"><code class="language-none"># 添加指定文件或目录到暂存区
git add [filename]
# 添加当前目录所有文件到暂存区
git add .
# 添加所有文件到暂存区
git add --all
# 删除文件
git rm [filename]
# 强制删除, 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 
git rm [filename] -f
# 把文件从暂存区域移除，但仍然希望保留在当前工作目录中
git rm --cached [filename]
# 文件重命名
git mv [filename] [newfilename]
# 强制重命名, 覆盖重复文件
git mv -f [filename] [newfilename]</code></pre>

<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><pre class="language-none"><code class="language-none"># 提交所有暂存区文件
git commit -m [msg]
# 提交指定文件
git commit [file1] [file2] ... -m [msg]
# 追加提交, 不产生新的commit的情况下将新修改的代码追加到前一次的commit中
# 也可用于修改commit msg
git commit --amend
# 空提交, 一般用于重跑ci
git commit --allow-empty -m [msg]</code></pre>

<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><pre class="language-none"><code class="language-none"># 回退至上个版本
git reset HEAD^
# 回退某个文件到上个版本
git reset HEAD^ [filename]
# 回退到指定版本并保留当前版本改动
git reset [commit-id]
# 舍弃当前版本改动回退至指定版本
git reset --hard [commit-id]
# 回退到指定版本并将改动加入暂存区
git reset --soft [commit-id]
# 创建一个新的提交回退指定版本的内容(将制定commit-id提交的代码删除并生成一个新的提交)
git revert [commit-id]</code></pre>

<h2 id="代码合并"><a href="#代码合并" class="headerlink" title="代码合并"></a>代码合并</h2><pre class="language-none"><code class="language-none"># 将指定分支合并到当前分支, 有冲突需要解决冲突并提交新的commit
git merge [branch]
# 将指定分支作为base分支, 先处理冲突后按照时间线将commit合并, 对比merge合并提交的代码更加整洁
git rebase [branch]
# 将指定提交合并到当前分支
git cherry-pick [commit-id]</code></pre>

<h2 id="stash保存及恢复进度"><a href="#stash保存及恢复进度" class="headerlink" title="stash保存及恢复进度"></a>stash保存及恢复进度</h2><pre class="language-none"><code class="language-none"># 清理stash暂存区
git stash clear
# 将当前变动代码加入stash暂存区
git stash 
# 查看stash暂存区内容
git stash list 
# 将最后加入暂存区的内容提取到当前分支, 并从stash暂存区中删除
git stash pop
# 弹出stash暂存区中的指定内容
git stash pop [stash-id]</code></pre>

<h2 id="git-commit-Angular规范"><a href="#git-commit-Angular规范" class="headerlink" title="git commit Angular规范"></a>git commit Angular规范</h2><p>commit message的规范有助于我们对于提交历史的追溯, 也会让我们在每次提交时更加慎重</p>
<p>格式如下</p>
<pre class="language-none"><code class="language-none">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code></pre>

<ul>
<li><p>type(必须)</p>
<p>  用于说明git commit的类别，只允许使用下面的标识。</p>
</li>
<li><p>scope(可选)</p>
<p>  scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<p>  例如在Angular，可以是location，browser，compile，compile，rootScope， ngHref，ngClick，ngView等。如果你的修改影响了不止一个scope，你可以使用*代替。</p>
</li>
<li><p>subject(必须)</p>
<p>  subject是commit目的的简短描述，不超过50个字符。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>type选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>feat</td>
<td>新功能（feature）。</td>
</tr>
<tr>
<td>fix/to</td>
<td>修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。</td>
</tr>
<tr>
<td>fix</td>
<td>产生diff并自动修复此问题。适合于一次提交直接修复问题</td>
</tr>
<tr>
<td>to</td>
<td>只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix</td>
</tr>
<tr>
<td>docs</td>
<td>文档（documentation）。</td>
</tr>
<tr>
<td>style</td>
<td>格式（不影响代码运行的变动）。</td>
</tr>
<tr>
<td>refactor</td>
<td>重构（即不是新增功能，也不是修改bug的代码变动）。</td>
</tr>
<tr>
<td>test</td>
<td>增加测试。</td>
</tr>
<tr>
<td>chore</td>
<td>构建过程或辅助工具的变动。</td>
</tr>
<tr>
<td>revert</td>
<td>回滚到上一个版本。</td>
</tr>
<tr>
<td>merge</td>
<td>代码合并。</td>
</tr>
<tr>
<td>sync</td>
<td>同步主线或分支的Bug。</td>
</tr>
</tbody></table>
<p>提交示例</p>
<pre class="language-none"><code class="language-none">fix(login): 修复账号中有不合法字符导致校验错误
feat(export): 增加导出功能 </code></pre>
]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/posts/17954850-8d67-11ec-8505-fffcfa42a684/</url>
    <content><![CDATA[<h2 id="Dockerhub-搜索下载远程镜像"><a href="#Dockerhub-搜索下载远程镜像" class="headerlink" title="Dockerhub 搜索下载远程镜像"></a>Dockerhub 搜索下载远程镜像</h2><pre class="language-none"><code class="language-none"># 搜索
docker search ImageName
# 下载
docker pull ImageName 或 docker pull ImageName:VersionNumber</code></pre>

<h2 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h2><pre class="language-none"><code class="language-none">docker images [OPTIONS] [REPOSITORY[:TAG]]</code></pre>

<p>OPTIONS说明：</p>
<p>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；<br>–digests :显示镜像的摘要信息；<br>-f :显示满足条件的镜像；<br>–format :指定返回值的模板文件；<br>–no-trunc :显示完整的镜像信息；<br>-q :只显示镜像ID。</p>
<h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><pre class="language-none"><code class="language-none">docker rmi ImageName
docker rmi ImageName:VersionNumber</code></pre>

<h2 id="Dockerfile本地构建容器"><a href="#Dockerfile本地构建容器" class="headerlink" title="Dockerfile本地构建容器"></a>Dockerfile本地构建容器</h2><pre class="language-none"><code class="language-none">docker build -t image_name Dockerfile_path</code></pre>
<p>常用选项说明：</p>
<p>–build-arg=[] :设置镜像创建时的变量；<br>–cpu-shares :设置 cpu 使用权重；<br>–cpu-period :限制 CPU CFS周期；<br>–cpu-quota :限制 CPU CFS配额；<br>–cpuset-cpus :指定使用的CPU id；<br>–cpuset-mems :指定使用的内存 id；<br>–disable-content-trust :忽略校验，默认开启；<br>-f :指定要使用的Dockerfile路径；<br>–force-rm :设置镜像过程中删除中间容器；<br>–isolation :使用容器隔离技术；<br>–label=[] :设置镜像使用的元数据；<br>-m :设置内存最大值；<br>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；<br>–no-cache :创建镜像的过程不使用缓存；<br>–pull :尝试去更新镜像的新版本；<br>–quiet, -q :安静模式，成功后只输出镜像 ID；<br>–rm :设置镜像成功后删除中间容器；<br>–shm-size :设置/dev/shm的大小，默认值是64M；<br>–ulimit :Ulimit配置。<br>–squash :将 Dockerfile 中所有的操作压缩为一层。<br>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。<br>–network: 默认 default。在构建期间设置RUN指令的网络模式</p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><pre class="language-none"><code class="language-none"># 启动容器，如果本地没有要启动的镜像，会自动下载,每次新建一个容器
docker run ImageName
# 只是单纯的启动。不会新建容器
docker start Name or ID
# 交互是进入容器
docker run -it ImageName &#x2F;bin&#x2F;bash</code></pre>
<p>常用选项说明：</p>
<p>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；<br>-d: 后台运行容器，并返回容器ID；<br>-i: 以交互模式运行容器，通常与 -t 同时使用；<br>-P: 随机端口映射，容器内部端口随机映射到主机的端口<br>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口<br>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>–name=”nginx-lb”: 为容器指定一个名称；<br>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；<br>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；<br>-h “mars”: 指定容器的hostname；<br>-e username=”ritchie”: 设置环境变量；<br>–env-file=[]: 从指定文件读入环境变量；<br>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；<br>-m :设置容器使用内存最大值；<br>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；<br>–expose=[]: 开放一个端口或一组端口；<br>–volume , -v: 绑定一个卷</p>
<h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><pre class="language-none"><code class="language-none"># 列出所有容器
docker ps -a
# 仅查看当前正在运行的所有容器
docker ps
# 查看最后一次运行的容器
docker ps -l
# 查看容器日志
docker logs Name&#x2F;ID
# 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A：增加的，D： 删除的，C： 被改变的 
docker diff Name&#x2F;ID
# 查看容器进程pid
docker top Name&#x2F;ID</code></pre>

<h2 id="启动、停止、杀死一个容器"><a href="#启动、停止、杀死一个容器" class="headerlink" title="启动、停止、杀死一个容器"></a>启动、停止、杀死一个容器</h2><pre class="language-none"><code class="language-none"># 启动容器
docker start Name&#x2F;ID
# docker stop，支持“优雅退出”。先发送SIGTERM信号，在一段时间之后（10s）再发送SIGKILL信号。Docker内部的应用程序可以接收SIGTERM信号，然后做一些“退出前工作”，比如保存状态、处理当前请求等。
# docker kill，发送SIGKILL信号，应用程序直接退出。
docker stop Name&#x2F;ID
docker kill Name&#x2F;ID
# 重启容器
docker restart Name&#x2F;ID</code></pre>

<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><pre class="language-none"><code class="language-none"># 删除所有容器
docker rm &#96;docker ps -a -q&#96;
# 删除单个容器
docker rm Name&#x2F;ID</code></pre>

<h2 id="连接到正在运行中的容器"><a href="#连接到正在运行中的容器" class="headerlink" title="连接到正在运行中的容器"></a>连接到正在运行中的容器</h2><pre class="language-none"><code class="language-none"># --sig-proxy&#x3D;false ：此选项作用是按CTRL-D或CTRL-C不会关闭容器
docker attach --sig-proxy&#x3D;false Name&#x2F;ID</code></pre>

<h2 id="根据容器变动创建新的镜像"><a href="#根据容器变动创建新的镜像" class="headerlink" title="根据容器变动创建新的镜像"></a>根据容器变动创建新的镜像</h2><pre class="language-none"><code class="language-none">docker commit ID new_image_name</code></pre>
<p>常用选项说明:<br>-a :提交的镜像作者；<br>-c :使用Dockerfile指令来创建镜像；<br>-m :提交时的说明文字；<br>-p :在commit时，将容器暂停。</p>
<h2 id="保存和加载镜像"><a href="#保存和加载镜像" class="headerlink" title="保存和加载镜像"></a>保存和加载镜像</h2><pre class="language-none"><code class="language-none"># 保存镜像到一个tar包
docker save image_name -o file_path
# 加载一个tar包对象
docker load -i file_path</code></pre>

<h1 id="Dockefile-指令说明"><a href="#Dockefile-指令说明" class="headerlink" title="Dockefile 指令说明"></a>Dockefile 指令说明</h1><ul>
<li><p>FROM<br>构建镜像基于哪个镜像</p>
</li>
<li><p>MAINTAINER<br>镜像维护者姓名或邮箱地址</p>
</li>
<li><p>RUN<br>构建镜像时运行的指令</p>
</li>
<li><p>CMD<br>运行容器时执行的shell环境</p>
</li>
<li><p>VOLUME<br>指定容器挂载点到宿主机自动生成的目录或其他容器</p>
</li>
<li><p>USER<br>为RUN、CMD、和 ENTRYPOINT 执行命令指定运行用户</p>
</li>
<li><p>WORKDIR<br>为 RUN、CMD、ENTRYPOINT、COPY 和 ADD 设置工作目录，就是切换目录</p>
</li>
<li><p>HEALTHCHECH<br>健康检查</p>
</li>
<li><p>ARG<br>构建时指定的一些参数</p>
</li>
<li><p>EXPOSE<br>声明容器的服务端口（仅仅是声明）</p>
</li>
<li><p>ENV<br>设置容器环境变量</p>
</li>
<li><p>ADD<br>拷贝文件或目录到容器中，如果是URL或压缩包便会自动下载或自动解压</p>
</li>
<li><p>COPY<br>拷贝文件或目录到容器中，跟ADD类似，但不具备自动下载或解压的功能</p>
</li>
<li><p>ENTRYPOINT<br>运行容器时执行的shell命令</p>
</li>
</ul>
]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Pages+Hexo+Matery主题搭建个人博客</title>
    <url>/posts/1bfa13c0-7e9a-11ec-a2eb-93bcbf8a55e3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>随着工作经历等增加, 个人所接触的知识面广度也在增加, 最近发现有的之前掌握但很久不用的技术逐渐被遗忘, 于是决定创建此博客用做记录我的技术成长, 也方便在日后哪天需要用到对应知识时可以快速重温。</li>
<li>搭建博客的方式有很多种, 博客类的开源项目也很多, 综合搭建成本, 可扩展性, 性能等因素最终决定使用Git Pages+Hexo方式搭建</li>
</ul>
<h2 id="本文所使用环境如下"><a href="#本文所使用环境如下" class="headerlink" title="本文所使用环境如下:"></a>本文所使用环境如下:</h2><ul>
<li>  MacOs-11.0.1</li>
<li>  Node-16.9.1</li>
<li>  Hexo-5.4.1</li>
</ul>
<h2 id="GitHub创建Git-Pages仓库"><a href="#GitHub创建Git-Pages仓库" class="headerlink" title="GitHub创建Git Pages仓库"></a>GitHub创建Git Pages仓库</h2><ul>
<li>  登陆GitHub，新建一个名为”你的用户名.github.io”的仓库</li>
<li>  创建index.html文件并输入任意内容</li>
<li>  浏览器访问”https://你的用户名.github.io”查看是否创建成功</li>
</ul>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><pre class="language-python" data-language="python"><code class="language-python">brew install node
# 安装淘宝镜像
npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</code></pre>

<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><pre class="language-none"><code class="language-none">npm install -g hexo-cli</code></pre>
<h2 id="创建hexo博客"><a href="#创建hexo博客" class="headerlink" title="创建hexo博客"></a>创建hexo博客</h2><pre class="language-none"><code class="language-none">mkdir blogs
cd blogs
hexo init
npm install

# 测试目录是否初始化成功
hexo g
hexo s</code></pre>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ul>
<li>  修改blogs/_config.yml关联Git Pages仓库</li>
</ul>
<pre class="language-none"><code class="language-none">deploy:
    type: git
    repo: [Git Pages仓库地址]
    branch: master

# 安装部署插件
npm install hexo-deployer-git --save

# 部署
hexo clean
hexo d</code></pre>
<ul>
<li>  浏览器访问”https://你的用户名.github.io”查看是否部署成功</li>
</ul>
<h2 id="更换Matery主题"><a href="#更换Matery主题" class="headerlink" title="更换Matery主题"></a>更换Matery主题</h2><ul>
<li><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">Matery中文文档</a><ul>
<li>按照文档中内容完成配置</li>
</ul>
</li>
</ul>
<h2 id="发布新的博客"><a href="#发布新的博客" class="headerlink" title="发布新的博客"></a>发布新的博客</h2><pre class="language-none"><code class="language-none">hexo new post 文章名称
hexo clean
hexo d -g # 生成并部署</code></pre>
<h2 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h2><ul>
<li><p>Matery支持对指定文章进行加密, 即访问文章前需要校验密码</p>
<ul>
<li>修改主题配置, 即themes目录下指定主题的_config.yml文件<ul>
<li>  找到配置中的verifyPassword开启</li>
</ul>
</li>
<li>  在需要加密的文章Front-matter中增加 password: SHA256加密密码(注: 需要将sha256结果转为16进制纯小写, 谷歌搜到的很多在线工具默认加密结果为大写会导致密码校验失败)</li>
<li>  访问文章时弹窗中输入sha256加密前的密码</li>
</ul>
</li>
<li><p>hexo-blog-encrypt插件实现文章加密</p>
<ul>
<li>  安装加密插件<pre class="language-none"><code class="language-none">npm install hexo-blog-encrypt --save</code></pre></li>
<li>  外层配置文件增加配置项(注: 并非选定主题中的_config.yml)<pre class="language-none"><code class="language-none"># Security
# 在需要加密的文章中增加private或protected标签即可, 访问密码为tags中对应password
encrypt: # hexo-blog-encrypt
    silent: true
    abstract: 这是一篇加密文章，需要密码才能继续阅读。
    message: 当前文章暂不对外可见，请输入密码后查看！
    tags:  
    - &#123;name: private, password: password1&#125;
    - &#123;name: protected, password: password2&#125;
    wrong_pass_message: 抱歉，您输入的密码错误，请检查后重新输入。
    wrong_hash_message: 抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。</code></pre></li>
</ul>
</li>
</ul>
<h2 id="固定url"><a href="#固定url" class="headerlink" title="固定url"></a>固定url</h2><p>解决修改文章名后url变化问题</p>
<pre class="language-none"><code class="language-none">npm install hexo-uuid --save</code></pre>
<p>修改外部_config.xml配置文件中的permalink</p>
<pre class="language-none"><code class="language-none">permalink: posts&#x2F;:uuid&#x2F;</code></pre>

<h2 id="Front-matter-可选项"><a href="#Front-matter-可选项" class="headerlink" title="Front-matter 可选项"></a>Front-matter 可选项</h2><table>
<thead>
<tr>
<th>配置选项</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td><code>Markdown</code> 的文件标题</td>
<td>文章标题，强烈建议填写此选项</td>
</tr>
<tr>
<td>date</td>
<td>文件创建时的日期时间</td>
<td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td>
</tr>
<tr>
<td>author</td>
<td>根 <code>_config.yml</code> 中的 <code>author</code></td>
<td>文章作者</td>
</tr>
<tr>
<td>img</td>
<td><code>featureImages</code> 中的某个值</td>
<td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td>
</tr>
<tr>
<td>top</td>
<td><code>true</code></td>
<td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td>
</tr>
<tr>
<td>hide</td>
<td><code>false</code></td>
<td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td>
</tr>
<tr>
<td>cover</td>
<td><code>false</code></td>
<td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td>
</tr>
<tr>
<td>coverImg</td>
<td>无</td>
<td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td>
</tr>
<tr>
<td>password</td>
<td>无</td>
<td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td>
</tr>
<tr>
<td>toc</td>
<td><code>true</code></td>
<td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td>
</tr>
<tr>
<td>mathjax</td>
<td><code>false</code></td>
<td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td>
</tr>
<tr>
<td>summary</td>
<td>无</td>
<td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td>
</tr>
<tr>
<td>categories</td>
<td>无</td>
<td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td>
</tr>
<tr>
<td>tags</td>
<td>无</td>
<td>文章标签，一篇文章可以多个标签</td>
</tr>
<tr>
<td>keywords</td>
<td>文章标题</td>
<td>文章关键字，SEO 时需要</td>
</tr>
<tr>
<td>reprintPolicy</td>
<td>cc_by</td>
<td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="language-none"><code class="language-none">---
title: typora-vue-theme主题介绍
date: 2018-09-07 09:25:00
author: 赵奇
img: &#x2F;source&#x2F;images&#x2F;xxx.jpg
top: true
hide: false
cover: true
coverImg: &#x2F;images&#x2F;1.jpg
password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92
toc: false
mathjax: false
summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要
categories: Markdown
tags:
  - Typora
  - Markdown
---</code></pre>]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Compose使用教程</title>
    <url>/posts/61a3c330-8e21-11ec-a105-f340cf877f8a/</url>
    <content><![CDATA[<p>本文参考自 <a href="https://www.runoob.com/docker/docker-compose.html">https://www.runoob.com/docker/docker-compose.html</a></p>
<h2 id="Compose简介"><a href="#Compose简介" class="headerlink" title="Compose简介"></a>Compose简介</h2><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>应用场景:</p>
<p>比如一个web服务包含web应用程序, 数据库等等, 我们本地构建一个web应用程序Dockfile, 再构建一个数据库Dockfile, 通过Compose可以将两个服务在隔离环境中一起运行</p>
<h2 id="docker-compose-yml-配置指令参考"><a href="#docker-compose-yml-配置指令参考" class="headerlink" title="docker-compose.yml 配置指令参考"></a>docker-compose.yml 配置指令参考</h2><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>指定本 yml 依从的 compose 哪个版本制定的。</p>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>指定为构建镜像上下文路径：<br>例如 webapp 服务，指定为从上下文路径 ./dir/Dockerfile 所构建的镜像</p>
<pre class="language-none"><code class="language-none">version: &quot;3.7&quot;
services:
webapp:
build: .&#x2F;dir</code></pre>
<p>或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：</p>
<pre class="language-none"><code class="language-none">version: &quot;3.7&quot;
services:
  webapp:
    build:
      context: .&#x2F;dir
      dockerfile: Dockerfile-alternate
      args:
        buildno: 1
      labels:
        - &quot;com.example.description&#x3D;Accounting webapp&quot;
        - &quot;com.example.department&#x3D;Finance&quot;
        - &quot;com.example.label-with-empty-value&quot;
      target: prod</code></pre>
<ul>
<li>context：上下文路径。</li>
<li>dockerfile：指定构建镜像的 Dockerfile 文件名。</li>
<li>args：添加构建参数，这是只能在构建过程中访问的环境变量。</li>
<li>labels：设置构建镜像的标签。</li>
<li>target：多层构建，可以指定构建哪一层。</li>
</ul>
<h3 id="cap-add，cap-drop"><a href="#cap-add，cap-drop" class="headerlink" title="cap_add，cap_drop"></a>cap_add，cap_drop</h3><p>添加或删除容器拥有的宿主机的内核功能。</p>
<pre class="language-none"><code class="language-none">cap_add:
  - ALL # 开启全部权限

cap_drop:
  - SYS_PTRACE # 关闭 ptrace权限</code></pre>

<h3 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h3><p>为容器指定父 cgroup 组，意味着将继承该组的资源限制。</p>
<h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>覆盖容器启动的默认命令</p>
<h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>指定容器名称</p>
<h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><p>设置依赖关系</p>
<ul>
<li>docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。</li>
<li>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。</li>
<li>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。</li>
</ul>
<h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h3><p>指定设备映射列表 (等同于 docker run –device 的作用)</p>
<h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h3><p>自定义DNS服务器。可以是单个值或列表。(等同于 docker run –dns 的作用)</p>
<h3 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h3><p>设置 DNS 搜索域(等同于 docker run –dns-search 的作用)</p>
<h3 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h3><p>覆盖容器的默认 entrypoint 指令 (等同于 docker run –entrypoint 的作用)</p>
<h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>添加环境变量。可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。</p>
<pre class="language-none"><code class="language-none">environment:
  RACK_ENV: development
  SHOW: &#39;true&#39;</code></pre>

<h3 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h3><p>指定环境变量文件。可以是单个值或列表的多个值。</p>
<pre class="language-none"><code class="language-none">env_file:
  - .&#x2F;common.env
  - .&#x2F;apps&#x2F;web.env
  - &#x2F;opt&#x2F;secrets.env</code></pre>

<h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>
<p>仅可以指定内部端口为参数：</p>
<pre class="language-none"><code class="language-none">expose:
 - &quot;3000&quot;
 - &quot;8000&quot;</code></pre>

<h3 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h3><p>添加主机名映射。类似 docker client –add-host。</p>
<pre class="language-none"><code class="language-none">extra_hosts:
 - &quot;somehost:162.242.195.82&quot;
 - &quot;otherhost:50.31.209.229&quot;</code></pre>
<p>以上会在此服务的内部容器中 /etc/hosts 创建一个具有 ip 地址和主机名的映射关系：</p>
<pre class="language-none"><code class="language-none">162.242.195.82  somehost
50.31.209.229   otherhost</code></pre>

<h3 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h3><p>用于检测 docker 服务是否健康运行。类似于 Dockerfile 的 HEALTHCHECK 指令</p>
<pre class="language-none"><code class="language-none">healthcheck:
  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost&quot;] # 设置检测程序
  interval: 1m30s # 设置检测间隔
  timeout: 10s # 设置检测超时时间
  retries: 3 # 设置重试次数
  start_period: 40s # 启动后，多少秒开始启动检测程序</code></pre>
<h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>指定容器运行的镜像。以下格式都可以：</p>
<pre class="language-none"><code class="language-none">image: redis
image: ubuntu:14.04
image: tutum&#x2F;influxdb
image: example-registry.com:4000&#x2F;postgresql
image: a4bc65fd # 镜像id</code></pre>

<h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>服务的日志记录配置。</p>
<p>driver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项</p>
<pre class="language-none"><code class="language-none">driver: &quot;json-file&quot;
driver: &quot;syslog&quot;
driver: &quot;none&quot;</code></pre>
<p>仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。</p>
<pre class="language-none"><code class="language-none">logging:
  driver: json-file
  options:
    max-size: &quot;200k&quot; # 单个文件大小为200k
    max-file: &quot;10&quot; # 最多10个文件</code></pre>

<p>当达到文件限制上限，会自动删除旧得文件。</p>
<p>syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。</p>
<pre class="language-none"><code class="language-none">logging:
  driver: syslog
  options:
    syslog-address: &quot;tcp:&#x2F;&#x2F;192.168.0.42:123&quot;</code></pre>

<h3 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h3><p>设置网络模式</p>
<pre class="language-none"><code class="language-none">network_mode: &quot;bridge&quot;
network_mode: &quot;host&quot;
network_mode: &quot;none&quot;
network_mode: &quot;service:[service name]&quot;
network_mode: &quot;container:[container name&#x2F;id]&quot;</code></pre>
<h3 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h3><p>配置容器连接的网络，引用顶级 networks 下的条目 。</p>
<pre class="language-none"><code class="language-none">services:
  some-service:
    networks:
      some-network:
        aliases:
         - alias1
      other-network:
        aliases:
         - alias2
networks:
  some-network:
    # Use a custom driver
    driver: custom-driver-1
  other-network:
    # Use a custom driver which takes special options
    driver: custom-driver-2</code></pre>
<h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><pre><code>- no：是默认的重启策略，在任何情况下都不会重启容器。
- always：容器总是重新启动。
- on-failure：在容器非正常退出时（退出状态非0），才会重启容器。
- unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器
</code></pre>
<pre class="language-none"><code class="language-none">restart: &quot;no&quot;
restart: always
restart: on-failure
restart: unless-stopped</code></pre>
<h3 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h3><p>存储敏感数据，例如密码：</p>
<pre class="language-none"><code class="language-none">version: &quot;3.1&quot;
services:

mysql:
  image: mysql
  environment:
    MYSQL_ROOT_PASSWORD_FILE: &#x2F;run&#x2F;secrets&#x2F;my_secret
  secrets:
    - my_secret

secrets:
  my_secret:
    file: .&#x2F;my_secret.txt</code></pre>

<h3 id="stop-grace-period"><a href="#stop-grace-period" class="headerlink" title="stop_grace_period"></a>stop_grace_period</h3><p>指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。默认的等待时间是 10 秒。</p>
<pre class="language-none"><code class="language-none">stop_grace_period: 1s # 等待 1 秒
stop_grace_period: 1m30s # 等待 1 分 30 秒 </code></pre>

<h3 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a>stop_signal</h3><p>设置停止容器的替代信号。默认情况下使用 SIGTERM 。</p>
<p>以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。</p>
<pre class="language-none"><code class="language-none">stop_signal: SIGUSR1</code></pre>

<h3 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h3><p>设置容器中的内核参数，可以使用数组或字典格式。</p>
<pre class="language-none"><code class="language-none">sysctls:
  net.core.somaxconn: 1024
  net.ipv4.tcp_syncookies: 0

sysctls:
  - net.core.somaxconn&#x3D;1024
  - net.ipv4.tcp_syncookies&#x3D;0</code></pre>

<h3 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h3><p>在容器内安装一个临时文件系统。可以是单个值或列表的多个值。</p>
<pre class="language-none"><code class="language-none">tmpfs: &#x2F;run

tmpfs:
  - &#x2F;run
  - &#x2F;tmp</code></pre>
<h3 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h3><p>覆盖容器默认的 ulimit。</p>
<pre class="language-none"><code class="language-none">ulimits:
  nproc: 65535
  nofile:
    soft: 20000
    hard: 40000</code></pre>
<h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>将主机的数据卷或着文件挂载到容器里。</p>
<pre class="language-none"><code class="language-none">version: &quot;3.7&quot;
services:
  db:
    image: postgres:latest
    volumes:
      - &quot;&#x2F;localhost&#x2F;postgres.sock:&#x2F;var&#x2F;run&#x2F;postgres&#x2F;postgres.sock&quot;
      - &quot;&#x2F;localhost&#x2F;data:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data&quot;</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>解决node.js mysql客户端不支持认证协议引发的“ER_NOT_SUPPORTED_AUTH_MODE”问题</title>
    <url>/posts/35c7b920-8f06-11ec-ade8-474d01fc45a2/</url>
    <content><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>当我在使用node的sequelize连接mysql8.0数据库时发生以下异常:</p>
<pre class="language-none"><code class="language-none">at Socket.emit (node:events:394:28)
    at addChunk (node:internal&#x2F;streams&#x2F;readable:315:12)
    at readableAddChunk (node:internal&#x2F;streams&#x2F;readable:289:9)
    at Socket.Readable.push (node:internal&#x2F;streams&#x2F;readable:228:10)
    at TCP.onStreamRead (node:internal&#x2F;stream_base_commons:199:23) &#123;
  code: &#39;ER_NOT_SUPPORTED_AUTH_MODE&#39;,
  errno: 1251,
  sqlState: &#39;08004&#39;,
  sqlMessage: &#39;Client does not support authentication protocol requested by server; consider upgrading MySQL client&#39;
&#125;,
original: Error: Client does not support authentication protocol requested by server; consider upgrading MySQL client
</code></pre>

<h2 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h2><p>Node最新的mysql模块并未完全支持MySQL 8的“caching_sha2_password”加密方式，而“caching_sha2_password”在MySQL 8中是默认的加密方式。因此，下面的方式命令是默认已经使用了“caching_sha2_password”加密方式，该账号对应的密码无法在Node mysql模块下被识别。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>修改用户密码的加密方式</p>
<p>查询对应用户的host及plugin</p>
<pre class="language-none"><code class="language-none">mysql&gt; select user,host, plugin from mysql.user;
+------------------+------+-----------------------+
| user             | host | plugin                |
+------------------+------+-----------------------+
|                  |      | caching_sha2_password |
| mysql.infoschema | %    | caching_sha2_password |
| mysql.session    | %    | caching_sha2_password |
| mysql.sys        | %    | caching_sha2_password |
| root             | %    | caching_sha2_password |
+------------------+------+-----------------------+</code></pre>
<p>从查询结果中可以看出root用户使用了caching_sha2_password方式加密密码, 将其修改为Node mysql支持的mysql_native_password方式</p>
<pre class="language-none"><code class="language-none"># root为待连接的用户, % 需要根据上方sql语句的host查询结果录入, 一般为localhost或%
mysql&gt; ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;密码&#39;;
Query OK, 0 rows affected (0.12 sec)</code></pre>
<p>修改完成后重新查询:</p>
<pre class="language-none"><code class="language-none">mysql&gt; select user,host, plugin from mysql.user;
+------------------+------+-----------------------+
| user             | host | plugin                |
+------------------+------+-----------------------+
|                  |      | caching_sha2_password |
| mysql.infoschema | %    | caching_sha2_password |
| mysql.session    | %    | caching_sha2_password |
| mysql.sys        | %    | caching_sha2_password |
| root             | %    | mysql_native_password |
+------------------+------+-----------------------+</code></pre>
<p>root用户对应的plugin被改为了mysql_native_password, 重新运行Node代码即可</p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
</search>
